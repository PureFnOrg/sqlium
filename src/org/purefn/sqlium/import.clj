(ns org.purefn.sqlium.import
  (:require [clojure.java.jdbc :as jdbc]
            [clojure.set :as set]
            [clojure.string :as str]
            [clojure.tools.logging :as log]
            [clj-time.core :as time]
            [clj-time.coerce :as tc]
            [org.purefn.sqlium.dsl :as dsl]
            [org.purefn.sqlium.sql :as sql])
  (:import java.util.ArrayList
           java.sql.ResultSet))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Config defaults
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def default-batch-size 10000)

(def default-retries 2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn table-id
  "Returns keyword representing a table id field, eg :table/field."
  [table]
  (keyword (:name table) (:id table)))

(defn join-results
  "Takes a relationship map for a many relationship, table data, and
   the relationship's data, and joins the relationship data into the
   table data."
  [rel data rel-data]
  (let [{:keys [source-table target column]} rel
        rel-data-lookup (group-by #(get % column) rel-data)
        id-col (dsl/id-column source-table)]
    (map (fn [rec]
           (let [rec-id (get rec id-col)
                 rec-data (get rel-data-lookup rec-id)]
             (cond-> rec
               rec-data (assoc-in [:many-relationships column] rec-data))))
         data)))

(defn fetch-results
  "Takes the [sql col-aliases] tuple as returned by `sql/select` and
   fetches the results, renaming the keys in the returned records
   using col-aliases."
  [db sql-with-aliases opts]
  (let [[sql col-aliases] sql-with-aliases
        retries (:retries opts)
        retries (if (and (integer? retries) (pos? retries))
                  retries
                  default-retries)]
    ((fn q [retries]
       (try (->> (jdbc/query db [sql] opts)
                 (map #(set/rename-keys % col-aliases)))
            (catch Throwable t
              (if (pos? retries)
                (q (dec retries))
                (throw t)))))
     retries)))

(defn- result-set-column-list
  "Extracts a single column by name from each row of a ResultSet,
   adding it to an ArrayList."
  [^ResultSet rs colname]
  (let [alist (ArrayList. 1000)]
    (while (.next rs)
      (.add alist (.getObject rs colname)))
    alist))

(defn fetch-column
  "Efficient, low-level query function to return a collection of a
   single column. Takes a sql query, the column name to fetch, and
   returns an ArrayList with the values of that column."
  [db query column]
  (jdbc/db-query-with-resultset db [query] #(result-set-column-list % column)))

(defn import-many-relationship
  "Takes a db, a many relationship map, collection of source table data,
   and optional query opts map, retrieves the related data and merges
   it into the table data."
  ([db rel data]
   (import-many-relationship db rel data {}))
  ([db rel data query-opts]
   (when-let [sql-with-aliases (sql/many-relationship-select rel data)]
     (log/debug :fn "import-many-relationship"
                :query (first sql-with-aliases))
     (let [many-data (fetch-results db sql-with-aliases query-opts)
           many-rels (get-in rel [:target :relationships :many])]
       (reduce (fn [data rel]
                 (let [rel-data (import-many-relationship db rel data)]
                   (join-results rel data rel-data)))
               many-data
               many-rels)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; fetching ids
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn table-paths
  "Returns a map, keyed by table name, with all paths to get to that
   table in given compiled spec.

   A path is a vector of [table-with-rel* table-without-rel]

   Returns  `{table-name #{path}}`"
  ([table-spec]
   (table-paths {} [] table-spec))
  ([paths base-path table-spec]
   (let [{:keys [name fields]} table-spec
         rels (filter dsl/relationship? fields)
         base-table (dissoc table-spec :fields)
         table-path (conj base-path base-table)
         next-paths (update paths name (fnil conj #{}) table-path)]
     (reduce (fn [ps rel]
               (let [target (:target rel)
                     base-rel (dissoc rel :target)]
                 (table-paths ps (conj base-path
                                       (assoc base-table :relationship base-rel))
                              target)))
             next-paths
             rels))))

(defn join-path
  "Takes a path (as from table-paths) and returns collection of maps
   describing each join in the path, containing:

   `{:base {:name \"table-name\"
            :alias \"optional-alias\"
            :join-col \"col-name\"}
     :target {:name \"table-name\"
              :alias \"table-alias\"
              :join-col \"col-name\"}`

   Table aliases are used so that tables can be repeated in a
   relationship chain. The aliases are generated by appending an
   incrementing number to the table name."
  [path]
  (->> path
       (partition 2 1)
       (map-indexed
        (fn [idx [t1 t2]]
          (let [{t1-id :id t1-name :name} t1
                {t2-id :id t2-name :name} t2
                join-col (get-in t1 [:relationship :column])
                many-rel? (when join-col
                            (= t2-name (namespace join-col)))
                t1-join-col (if many-rel?
                              t1-id
                              (name join-col))
                t2-join-col (if many-rel?
                              (name join-col)
                              t2-id)
                t1-alias (when (pos? idx)
                           (str t1-name (dec idx)))
                t2-alias (str t2-name idx)]
            {:base {:name t1-name
                    :alias t1-alias
                    :join-col t1-join-col}
             :target {:name t2-name
                      :alias t2-alias
                      :join-col t2-join-col}})))))

(defn path-query
  "Takes a path as returned by `table-paths`, and a collection of
   conditions, and returns a query to retrieve ids from the base table
   in the path.

   Each condition is a map of:

   `{:column :table/col
     :comparator \"comparator-sym\"
     :value some-val}`"
  [path conditions]
  (let [{:keys [id name] :as base-table} (first path)
        base-query (format "SELECT %s AS id FROM %s"
                           (str name "." id)
                           name)
        joins? (> (count path) 1)
        jp (when joins? (join-path path))
        target-table (if joins?
                       (:target (last jp))
                       {:name name
                        :alias name})
        applicable-conds (filter #(= (:name target-table)
                                     (namespace (:column %)))
                                 conditions)]
    (str base-query
         (when joins?
           (str " "
                (->> jp
                     (map sql/inner-join-sql)
                     (str/join " "))))
         (when (seq applicable-conds)
           (str " WHERE "
                (->> applicable-conds
                         (map #(sql/condition-sql % (:alias target-table)))
                         (str/join " OR ")))))))

(defn expiry-condition
  "Returns condition map for an expiry."
  [expiry]
  (let [{:keys [field age]} expiry
        ;; picking an arbitrary cutoff number to distinguish #
        ;; of days from millisecond timestamp
        cutoff (if (and (number? age) (< age 100000))
                 (-> (time/now)
                     (time/to-time-zone (time/default-time-zone))
                     (time/minus (time/days age))
                     (time/with-time-at-start-of-day))
                 age)]
    {:column field
     :comparator ">"
     :value (sql/mysql-date-string (tc/to-date-time cutoff))}))

;; TODO: push this time stuff to the client

(defn delta-condition
  "Returns condition map for a delta field."
  [field date]
  {:column field
   :comparator ">"
   :value (sql/mysql-date-string (tc/to-date-time date))})

(defn condition-table
  "Returns the table used in a condition's column."
  [condition]
  (namespace (:column condition)))

(defn all-ids-query
  "Returns a query that will select all ids in the base table of
   spec."
  [spec]
  (let [{:keys [id name]} spec]
    (format "SELECT %s AS id FROM %s"
            id name)))

(defn update-table-id-query
  "Takes a map describing update table, and returns a query to
   retrieve ids to update. Update map has keys:

     * :table     Name of the update table
     * :id        Name of column with entity ids
     * :updated   Name of column with entity update datetimes.
     * :since     Datetime to return updates since."
  [{:keys [table id updated since] :as update-map}]
  (str (format "SELECT %s FROM %s"
               id table)
       (when (and updated since)
         (str "WHERE "
              (sql/condition-sql {:column (keyword table updated)
                                  :comparator ">"
                                  :value (sql/mysql-date-string (tc/to-date-time since))})))))

;; TODO: reconsider the interaction between expiry and delta here
;; looks like expiry gets unioned in, meaning it will kinda clobber delta

(defn id-query
  "Takes parsed spec (not grouped) and returns query to retrieve the
   ids, controlled by opts map.

   Fields specifying an update time (delta fields) can occur anywhere
   in an entity, and also possibly in several places. This generates a
   separate query for each specified delta field using the entity
   spec, and then UNIONs them together into a single query for
   efficient execution."
  [spec {:keys [delta expiry] :as opts}]
  (let [tables (table-paths spec)
        conds (cond->
                  (when delta
                    (map #(delta-condition % (:date delta))
                         (:fields delta)))
                expiry (conj (expiry-condition expiry)))
        cond-tables (set (map condition-table conds))
        paths (mapcat (partial get tables) cond-tables)
        queries (map #(path-query % conds) paths)]
    (if (seq queries)
      (str/join " UNION " queries)
      (all-ids-query spec))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; main API
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; How this works

;; - queries for all the ids to fetch as part of the import
;;   - this query uses all the conditions/options passed in
;;   - joins in the full depth of the data spec, so we can have delta
;;     and expiry fields anywhere in the entity
;; - returns a lazy seq, which will fetch the ids in batches of
;;   batch option or `default-batch-size`

(defn fetch-ids
  "Takes an analyzed DSL spec and selection options map, and returns an
   ArrayList of ids.

   The selections map has the same options as the main
   API. :update, :delta and/or :expiry"
  [db spec {:keys [delta expiry update-table]
            :as opts}]
  (let [id-col (table-id (:grouped spec))
        ids-q (if update-table
                (update-table-id-query update-table)
                (id-query spec opts))]
    (fetch-column db ids-q "id")))

(defn fetch-records
  "Takes an analyzed DSL entity spec, collection of entity ids, and opts
   map, and performs the queries to fetch the table data and its
   associated relationships. opts map has keys:

    * :batch    Batch size, either a number or false to disable
                batching (ie. fetch all at once)
    * :retries  Max number of retries [2]
    * :timeout  Optional query timeout in milliseconds

   The resulting records have keys in the form of :table/column for
   each group, and many-relationships
   in [:many-relationships :foreign-table/column] keys.

   Returns a lazy-seq of results."
  ([db entity-spec ids]
   (fetch-records db entity-spec ids {}))
  ([db entity-spec ids {:keys [batch]
                        :or {batch default-batch-size}
                        :as opts}]
   (let [{:keys [grouped spec]} entity-spec
         col-aliases (sql/group-column-mappings grouped)
         id-col (table-id grouped)
         cnt (count ids)
         _ (log/info :fn "fetch-records"
                     :msg (str "Fetching " cnt " ids"))
         data-query (str "SELECT " (sql/aliased-fields-statement col-aliases)
                         " " (sql/from-statement grouped false))
         many-rels (get-in grouped [:relationships :many])
         query-opts (select-keys opts [:timeout :retries])]
     (with-meta
       ((fn next-batch
          ([batches]
           (next-batch batches 0))
          ([batches position]
           (let [cur (first batches)]
             (if-not (seq cur)
               (list)
               (lazy-seq
                (let [cur-query (str data-query " WHERE "
                                     (sql/in-statement  {:field id-col
                                                         :vals cur}))
                      _ (log/debug :fn "fetch-records"
                                   :msg "Fetching next chunk of records"
                                   :query cur-query
                                   :position position
                                   :total cnt)
                      table-data (fetch-results db [cur-query col-aliases] query-opts)
                      entity-data
                      (reduce (fn [data rel]
                                (if-let [rel-data (import-many-relationship db rel data query-opts)]
                                  (join-results rel data rel-data)
                                  data))
                              table-data
                              many-rels)]
                  (concat entity-data (next-batch (rest batches)
                                                  (+ position batch)))))))))
        (if (and (integer? batch) (pos? batch))
          (partition-all batch ids)
          ids))
       {:total cnt}))))

(defn import-record
  "Like import-table, but returns single record from given db."
  [db table-spec entid]
  (let [{:keys [spec grouped]} table-spec
        col-aliases (sql/group-column-mappings grouped)
        id-col (table-id grouped)
        ent-query (str "SELECT " (sql/aliased-fields-statement col-aliases)
                       " " (sql/from-statement grouped false)
                       " WHERE " (sql/condition-sql {:column id-col
                                                     :value entid}))
        many-rels (get-in grouped [:relationships :many])
        ent-data (fetch-results db [ent-query col-aliases] {})]
    (first
     (reduce (fn [data rel]
               (if-let [rel-data (import-many-relationship db rel data)]
                 (join-results rel data rel-data)
                 data))
             ent-data
             many-rels))))
