<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>org.purefn.sqlium.import documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Sqlium</span> <span class="project-version">0.1.3-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>org</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>purefn</span></div></div></li><li class="depth-3"><a href="org.purefn.sqlium.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sqlium</span></div></a></li><li class="depth-4 current"><a href="org.purefn.sqlium.import.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>import</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-all-ids-query"><div class="inner"><span>all-ids-query</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-condition-table"><div class="inner"><span>condition-table</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-default-batch-size"><div class="inner"><span>default-batch-size</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-delta-condition"><div class="inner"><span>delta-condition</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-expiry-condition"><div class="inner"><span>expiry-condition</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-fetch-column"><div class="inner"><span>fetch-column</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-fetch-results"><div class="inner"><span>fetch-results</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-id-query"><div class="inner"><span>id-query</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-import-many-relationship"><div class="inner"><span>import-many-relationship</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-import-record"><div class="inner"><span>import-record</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-import-table"><div class="inner"><span>import-table</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-join-path"><div class="inner"><span>join-path</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-join-results"><div class="inner"><span>join-results</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-path-query"><div class="inner"><span>path-query</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-table-id"><div class="inner"><span>table-id</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-table-paths"><div class="inner"><span>table-paths</span></div></a></li><li class="depth-1"><a href="org.purefn.sqlium.import.html#var-update-table-id-query"><div class="inner"><span>update-table-id-query</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">org.purefn.sqlium.import</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-all-ids-query"><h3>all-ids-query</h3><div class="usage"><code>(all-ids-query spec)</code></div><div class="doc"><pre class="plaintext">Returns a query that will select all ids in the base table of
spec.</pre></div></div><div class="public anchor" id="var-condition-table"><h3>condition-table</h3><div class="usage"><code>(condition-table condition)</code></div><div class="doc"><pre class="plaintext">Returns the table used in a condition's column.
</pre></div></div><div class="public anchor" id="var-default-batch-size"><h3>default-batch-size</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-delta-condition"><h3>delta-condition</h3><div class="usage"><code>(delta-condition field date)</code></div><div class="doc"><pre class="plaintext">Returns condition map for a delta field.
</pre></div></div><div class="public anchor" id="var-expiry-condition"><h3>expiry-condition</h3><div class="usage"><code>(expiry-condition expiry)</code></div><div class="doc"><pre class="plaintext">Returns condition map for an expiry.
</pre></div></div><div class="public anchor" id="var-fetch-column"><h3>fetch-column</h3><div class="usage"><code>(fetch-column db query column)</code></div><div class="doc"><pre class="plaintext">Efficient, low-level query function to return a collection of a
single column. Takes a sql query, the column name to fetch, and
returns an ArrayList with the values of that column.</pre></div></div><div class="public anchor" id="var-fetch-results"><h3>fetch-results</h3><div class="usage"><code>(fetch-results db sql-with-aliases)</code></div><div class="doc"><pre class="plaintext">Takes the [sql col-aliases] tuple as returned by `sql/select` and
fetches the results, renaming the keys in the returned records
using col-aliases.</pre></div></div><div class="public anchor" id="var-id-query"><h3>id-query</h3><div class="usage"><code>(id-query spec {:keys [limit offset delta expiry], :as opts})</code></div><div class="doc"><pre class="plaintext">Takes parsed spec (not grouped) and returns query to retrieve the
ids, controlled by opts map.</pre></div></div><div class="public anchor" id="var-import-many-relationship"><h3>import-many-relationship</h3><div class="usage"><code>(import-many-relationship db rel data)</code></div><div class="doc"><pre class="plaintext">Takes a db, a many relationship map and collection of source table data,
retrieves the related data and merges it into the table data.</pre></div></div><div class="public anchor" id="var-import-record"><h3>import-record</h3><div class="usage"><code>(import-record db table-spec entid)</code></div><div class="doc"><pre class="plaintext">Like import-table, but returns single record from given db.
</pre></div></div><div class="public anchor" id="var-import-table"><h3>import-table</h3><div class="usage"><code>(import-table db table-spec)</code><code>(import-table db table-spec {:keys [limit offset delta expiry batch update-table], :or {batch default-batch-size}, :as opts})</code></div><div class="doc"><pre class="plaintext">Takes an analyzed DSL spec with a table at the top level, and opts
map, and performs the queries to fetch the table data and its
associated relationships. opts map has keys:

 * :limit   Number of records to retrieve [unlimited]
 * :offset  Starting record [0]
 * :delta   Turns the import into a deltas import. A map with
            parameters for retrieving deltas.
 * :update-table  Also turns into ino a deltas import. Preferred
            over :delta, if present. A map describing the table
            that contains entity ids to update.
 * :expiry  Spec for filter for records older than a specified
            number of days.
 * :batch   Batch size.

If present, the delta map should have keys:
 * :fields  Collection of :table/column (datetime) fields that will
            be used for update detection.
 * :date    Date to be used for comparison. Anything that clj-time can
            coerce to DateTime.

If present, the update-table map should have keys:
 * :table     Name of the update table
 * :id        Name of column with entity ids
 * :updated   Name of column with entity update datetimes.
 * :since     Datetime to return updates since.

If present, the expiry map should have keys:
 * :field   The :table/column (datetime) field that will be used to
            determine record age.
 * :age     DateTime of the cutoff.

The resulting records have keys in the form of :table/column for
each group, and many-relationships
in [:many-relationships :foreign-table/column] keys.

Returns a lazy-seq of results.</pre></div></div><div class="public anchor" id="var-join-path"><h3>join-path</h3><div class="usage"><code>(join-path path)</code></div><div class="doc"><pre class="plaintext">Takes a path (as from table-paths) and returns collection of maps
describing each join in the path, containing:

`{:base {:name "table-name"
         :alias "optional-alias"
         :join-col "col-name"}
  :target {:name "table-name"
           :alias "table-alias"
           :join-col "col-name"}`

Table aliases are used so that tables can be repeated in a
relationship chain. The aliases are generated by appending an
incrementing number to the table name.</pre></div></div><div class="public anchor" id="var-join-results"><h3>join-results</h3><div class="usage"><code>(join-results rel data rel-data)</code></div><div class="doc"><pre class="plaintext">Takes a relationship map for a many relationship, table data, and
the relationship's data, and joins the relationship data into the
table data.</pre></div></div><div class="public anchor" id="var-path-query"><h3>path-query</h3><div class="usage"><code>(path-query path conditions)</code></div><div class="doc"><pre class="plaintext">Takes a path as returned by `table-paths`, and a collection of
conditions, and returns a query to retrieve ids from the base table
in the path.

Each condition is a map of:

`{:column :table/col
  :comparator "comparator-sym"
  :value some-val}`</pre></div></div><div class="public anchor" id="var-table-id"><h3>table-id</h3><div class="usage"><code>(table-id table)</code></div><div class="doc"><pre class="plaintext">Returns keyword representing a table id field, eg :table/field.
</pre></div></div><div class="public anchor" id="var-table-paths"><h3>table-paths</h3><div class="usage"><code>(table-paths table-spec)</code><code>(table-paths paths base-path table-spec)</code></div><div class="doc"><pre class="plaintext">Returns a map, keyed by table name, with all paths to get to that
table in given compiled spec.

A path is a vector of [table-with-rel* table-without-rel]

Returns  `{table-name #{path}}`</pre></div></div><div class="public anchor" id="var-update-table-id-query"><h3>update-table-id-query</h3><div class="usage"><code>(update-table-id-query {:keys [table id updated since], :as update-map})</code></div><div class="doc"><pre class="plaintext">Takes a map describing update table, and returns a query to
retrieve ids to update. Update map has keys:

  * :table     Name of the update table
  * :id        Name of column with entity ids
  * :updated   Name of column with entity update datetimes.
  * :since     Datetime to return updates since.</pre></div></div></div></body></html>